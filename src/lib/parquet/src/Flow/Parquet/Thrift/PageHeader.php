<?php

declare(strict_types=1);
namespace Flow\Parquet\Thrift;

/**
 * Autogenerated by Thrift Compiler (0.19.0).
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;

class PageHeader extends TBase
{
    public static $_TSPEC = [
        1 => [
            'var' => 'type',
            'isRequired' => true,
            'type' => TType::I32,
            'class' => '\Flow\Parquet\Thrift\PageType',
        ],
        2 => [
            'var' => 'uncompressed_page_size',
            'isRequired' => true,
            'type' => TType::I32,
        ],
        3 => [
            'var' => 'compressed_page_size',
            'isRequired' => true,
            'type' => TType::I32,
        ],
        4 => [
            'var' => 'crc',
            'isRequired' => false,
            'type' => TType::I32,
        ],
        5 => [
            'var' => 'data_page_header',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\DataPageHeader',
        ],
        6 => [
            'var' => 'index_page_header',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\IndexPageHeader',
        ],
        7 => [
            'var' => 'dictionary_page_header',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\DictionaryPageHeader',
        ],
        8 => [
            'var' => 'data_page_header_v2',
            'isRequired' => false,
            'type' => TType::STRUCT,
            'class' => '\Flow\Parquet\Thrift\DataPageHeaderV2',
        ],
    ];

    public static $isValidate = false;

    /**
     * Compressed (and potentially encrypted) page size in bytes, not including this header *.
     *
     * @var int
     */
    public $compressed_page_size;

    /**
     * The 32-bit CRC checksum for the page, to be be calculated as follows:.
     *
     * - The standard CRC32 algorithm is used (with polynomial 0x04C11DB7,
     *   the same as in e.g. GZip).
     * - All page types can have a CRC (v1 and v2 data pages, dictionary pages,
     *   etc.).
     * - The CRC is computed on the serialization binary representation of the page
     *   (as written to disk), excluding the page header. For example, for v1
     *   data pages, the CRC is computed on the concatenation of repetition levels,
     *   definition levels and column values (optionally compressed, optionally
     *   encrypted).
     * - The CRC computation therefore takes place after any compression
     *   and encryption steps, if any.
     *
     * If enabled, this allows for disabling checksumming in HDFS if only a few
     * pages need to be read.
     *
     * @var int
     */
    public $crc;

    /**
     * @var DataPageHeader
     */
    public $data_page_header;

    /**
     * @var DataPageHeaderV2
     */
    public $data_page_header_v2;

    /**
     * @var DictionaryPageHeader
     */
    public $dictionary_page_header;

    /**
     * @var IndexPageHeader
     */
    public $index_page_header;

    /**
     * the type of the page: indicates which of the *_header fields is set *.
     *
     * @var int
     */
    public $type;

    /**
     * Uncompressed page size in bytes (not including this header) *.
     *
     * @var int
     */
    public $uncompressed_page_size;

    public function __construct($vals = null)
    {
        if (\is_array($vals)) {
            parent::__construct(self::$_TSPEC, $vals);
        }
    }

    public function getName()
    {
        return 'PageHeader';
    }

    public function read($input)
    {
        return $this->_read('PageHeader', self::$_TSPEC, $input);
    }

    public function write($output)
    {
        return $this->_write('PageHeader', self::$_TSPEC, $output);
    }
}
